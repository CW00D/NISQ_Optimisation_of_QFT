\documentclass[11pt,a4paper]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{titlesec}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{tabularx}

\setcounter{secnumdepth}{4}

% set table of content depth
\setcounter{tocdepth}{3} 
\usepackage[titles]{tocloft}

% set spacing 
\setlength{\cftbeforesecskip}{10pt}

% Page layout settings
\geometry{
  a4paper,
  left=20mm,
  right=20mm,
  top=25mm,
  bottom=25mm
}

\usepackage{biblatex}
\addbibresource{Project_Report_References.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\singlespacing % Set the document to single line spacing
\thispagestyle{empty} % Remove page number for the cover page

\begin{center}
{\bf \LARGE Approaches to Noise Resilient Quantum Circuit Design}\\[0.5cm]
  \textbf{Christian Wood} \\[0.2cm]
  \textbf{Student ID:} 710018541 \\[1cm]
\end{center}

\section*{Abstract}
\noindent 
One of the key challenges in quantum computing is designing quantum circuits, a task made difficult by their probabilistic behaviour and counter-intuitive nature. Various automated techniques have been proposed, with genetic algorithms emerging as a popular method. In the current NISQ era, noise poses a serious obstacle by introducing significant computational errors. By leveraging multi-objective evolutionary algorithms (MOEAs), our approach not only automates circuit design but also includes additional criteria to enhance performance under realistic noisy conditions. We present an a priori MOEA that adapts to the design of arbitrary circuits along with a novel circuit representation scheme. We demonstrate the method’s effectiveness by applying it to the 2 and 3-qubit Quantum Fourier Transform (QFT), showing that the evolved circuits perform better in noisy environments than the traditional QFT circuit.

\newpage
\thispagestyle{empty} 
\section*{Declaration}
I acknowledge the following uses of GenAI tools in this assessment: 

\begin{itemize}[label={\ $\square$\ }, leftmargin=*]
 \item I have used GenAI tools to:
 \begin{itemize}[label={\ $\square$\ }, leftmargin=*]
  \item develop ideas.
  \item assist with research or gathering information.
  \item help me understand key theories and concepts.
  \item identify trends and themes as part of my data analysis.
  \item suggest a plan or structure for my assessment.
  \item give me feedback on a draft.
  \item generate images, figures or diagrams.
  \item proofread and correct grammar or spelling errors.
  \item generate citations or references.
  \item Other: [please specify]
  \item[]
 \end{itemize}
 \item I have not used any GenAI tools in preparing this assessment.
\end{itemize}

\bigskip
I declare that I have referenced all use of GenAI outputs within my assessment in line with the University referencing guidelines.

\vspace{1em}
I certify that all material in this dissertation which is not my own has been identified. 

\vspace{5em}
{\bf\noindent Signature:} \hrulefill
\newpage

% Table of Contents
\tableofcontents 
\thispagestyle{empty} 
\newpage 

% Reset page numbering for main report
\clearpage
\pagenumbering{arabic} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Introduction
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
Quantum computing represents a fundamental shift in computational paradigms, harnessing the principles of quantum mechanics to perform operations that are infeasible on classical machines. Unlike classical bits, which are strictly binary, quantum bits, known as qubits, exploit superposition \cite{Gudder1970ASP}, allowing them to exist in a linear combination of both $\ket{0}$ and $\ket{1}$ states simultaneously. Alongside this, the phenomenon of quantum entanglement \cite{horodecki2009quantum} permits correlations between qubits that transcend classical limits, enabling quantum systems to explore vast computational spaces in parallel.\newline

This inherent parallelism underpins quantum computing's potential to offer exponential or quadratic speedups for a variety of computational problems which were previously intractable. Shor’s algorithm \cite{Shor365700}, for instance, enables exponential acceleration in integer factorisation, posing a credible threat to classical cryptographic schemes. Similarly, Grover’s algorithm \cite{Khanal2021QuantumML} achieves a quadratic improvement in search across unstructured datasets. These theoretical milestones highlight quantum computing’s transformative potential across diverse fields such as cryptography, optimisation, and chemistry.\newline

Despite this promise, practical quantum computation remains severely constrained by the limitations of contemporary quantum hardware. We are currently situated within the so-called Noisy Intermediate-Scale Quantum (NISQ) era \cite{Preskill2018QuantumCI}, characterised by devices comprising tens to a few thousand qubits. These systems are susceptible to various forms of quantum noise, including environmental decoherence, gate infidelity, and readout errors, which compromise computation fidelity as circuit depth increases \cite{Clerk2008IntroductionTQ}. Moreover, limited qubit connectivity necessitates the insertion of SWAP gates to enable interactions between non-adjacent qubits, thereby increasing depth and compounding errors \cite{Preskill2018QuantumCI}.\newline

Compounding these hardware limitations is the intrinsic complexity of quantum circuit design itself. Unlike classical circuits, quantum circuits operate under non-intuitive quantum logic and must account for reversibility, entanglement, and decoherence sensitivity, making manual design both challenging and error-prone. This motivates the use of algorithmic design strategies that can explore complex solution spaces with minimal human intervention.\newline

One promising software-level solution lies in the use of Evolutionary Algorithms (EAs) \cite{Lukac2002EvolvingQC}, a class of bio-inspired metaheuristics that systematically explore large search spaces through mechanisms such as mutation and crossover. Multi-Objective Evolutionary Algorithms (MOEAs) \cite{moein} extend this framework by simultaneously optimising multiple, often competing, objectives-such as circuit fidelity and circuit depth. This enables the generation of quantum circuits that are both functionally correct and better suited to execution on imperfect, noise-prone hardware.\newline

In this work, we introduce a novel MOEA-based framework for quantum circuit design that utilises a layer-based encoding scheme to permit concurrent gate execution. This encoding is coupled with a suite of custom genetic operators and scalarised fitness functions that combine ideal state fidelity, noise-aware simulation, and depth penalties. This framework not only facilitates exploration of a wider space of functionally viable circuits but also encourages evolution toward architectures that mitigate the deleterious effects of quantum noise.\newline

To evaluate the efficacy of this approach, we target the Quantum Fourier Transform (QFT) \cite{Jozsa1997QuantumAA} as a benchmark, a foundational component in numerous quantum algorithms including Shor’s algorithm and quantum phase estimation. The QFT’s structural regularity and sensitivity to noise make it an ideal benchmark for assessing automated optimisation strategies. This dissertation presents and evaluates evolved QFT implementations for both 2- and 3-qubit systems, demonstrating that the MOEA-generated circuits exhibit improved performance under noisy conditions when compared to standard textbook implementations.\newline

These results underscore the viability of MOEA-based quantum circuit synthesis for the NISQ era, and open new avenues for scalable, noise-aware circuit optimisation tailored to near-term quantum hardware.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Background and Integrated Literature Review
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background and Research Goals}
\subsection{Background}
While the Introduction established the conceptual and practical challenges of quantum computing in the NISQ era, this section provides a more technical analysis of the implications for circuit design and optimisation. Current quantum devices not only face limitations in qubit count and coherence time but also introduce architectural constraints that significantly affect performance.\newline

One of the central design pressures stems from quantum noise, which includes amplitude damping, dephasing, and depolarising effects~\cite{Clerk2008IntroductionTQ}. These noise channels are typically modelled during simulation using realistic error rates drawn from hardware specifications. Tools such as Qiskit Aer allow for detailed modelling of these effects, providing a valuable testing ground for evaluating circuit robustness prior to deployment. Importantly, noise sensitivity is not uniform across gates; two-qubit operations such as CNOTs and controlled-phase gates generally introduce higher error rates, and these accumulate with depth~\cite{Chow2012UniversalQG}.\newline

Another critical constraint arises from the limited physical connectivity between qubits. On most current devices, qubits cannot interact directly unless physically adjacent, which necessitates the insertion of SWAP gates to permute qubit locations. Each SWAP comprises three CNOT gates, compounding the error burden and increasing execution time. While this issue is partially addressed through routing algorithms during transpilation, recent studies suggest that topology-aware circuit synthesis, which takes hardware connectivity into account from the outset, can yield significantly more efficient circuits~\cite{Pedram2016LayoutOF}.\newline

Against this backdrop, software-level optimisation strategies have emerged as a compelling way to bridge the gap between algorithmic intent and hardware feasibility. Among these, evolutionary algorithms have demonstrated promise due to their flexibility in navigating rugged, high-dimensional search landscapes. When extended to multi-objective formulations, MOEAs allow for the simultaneous optimisation of several competing metrics, including fidelity, circuit depth, gate count, and even hardware-specific constraints~\cite{Zhou2011MultiobjectiveEA, Sarvaghad_Moghaddam}. These capabilities make MOEAs particularly well suited for quantum circuit synthesis, where trade-offs between correctness and resilience are unavoidable.\newline

In particular, the representation of circuits within an evolutionary framework plays a pivotal role. While serial encodings are simple and compact, they lack support for parallel gate execution, which is essential for depth reduction. Layered or block-based representations, by contrast, allow for concurrent operations on independent qubits, providing a natural fit for MOEAs targeting noise-sensitive hardware. When combined with a fitness landscape that includes noisy fidelity metrics and structural penalties, these representations enable a design pipeline that is both flexible and hardware-aware.

\subsection{Research Objectives}
This dissertation builds upon these developments by proposing an evolutionary framework tailored for the automated design of noise-resilient quantum circuits. Specifically, the following research objectives are addressed:

\begin{enumerate}
    \item \textbf{Develop a flexible circuit representation scheme} based on a layered structure that allows for concurrent gate execution and captures both single- and multi-qubit interactions. This encoding aims to preserve temporal structure while enabling efficient genetic operations such as crossover and mutation.

    \item \textbf{Design and implement a set of custom MOEA components}, including scalarised fitness functions that incorporate both ideal state fidelity and performance under realistic noise models, as well as penalties for circuit depth. These fitness functions are intended to balance accuracy, noise resilience, and computational efficiency.

    \item \textbf{Evaluate the framework on a benchmark circuit}-the Quantum Fourier Transform (QFT)-across both 2- and 3-qubit variants. The evaluation includes fidelity measurements under both noiseless and noisy conditions, structural comparison to textbook implementations, and analysis of evolved circuit features contributing to improved robustness.
\end{enumerate}

Through these objectives, the dissertation aims to demonstrate that MOEA-based approaches can produce functionally correct, hardware-aware circuit designs that are better adapted to the realities of near-term quantum processors.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Genetic Algorithm Design
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Genetic Algorithm Design}
\subsection{Circuit Representation}
A central challenge in applying evolutionary algorithms to quantum circuit design lies in creating a representation that is both expressive enough to capture complex quantum behaviour, and structured enough to permit efficient manipulation through genetic operators. This work adopts a layer-based representation scheme, inspired by the block-based encodings used in previous literature~\cite{Lukac2002EvolvingQC}, with enhancements designed to support noise-aware optimisation on NISQ devices.\newline

Each circuit is represented by a chromosome using an ordered list of \textit{layers}, where each layer corresponds to a discrete timestep. A layer is a list of gate specification strings, one per qubit, indicating the operation (if any) applied to that qubit during that timestep. Single-, two-, and three-qubit gates are supported, including parametrised variants. Gates applied within the same layer must act on disjoint sets of qubits, enabling concurrent execution and directly influencing the circuit’s effective depth.

\subsubsection*{Gate Specifications} Each gate is encoded as a string using the format \texttt{gate(args)}, where \texttt{args} may include control qubit indices and rotation parameters. Partner qubits in multi-qubit gates are marked with a special symbol \texttt{"-"}, while idle qubits are annotated with a \texttt{"w"} (barrier). Table~\ref{tab:gateset} summarises the full gate set used in this work, including arities, parameters, and descriptions.

\begin{table}[H]
    \centering
    \begin{tabular}{llll}
        \toprule
        \textbf{Gate} & \textbf{Qubit Arity} & \textbf{Parameters} & \textbf{Description} \\
        \midrule
        x, y, z, h, s, sdg, t, tdg & 1 & None & Basic single-qubit gates \\
        rx, ry, rz & 1 & $\theta$ & Rotation around X, Y, or Z axis \\
        cx, cy, cz & 2 & control & Controlled Pauli operations \\
        swap & 2 & None & Swap operation \\
        crx, cry, crz, cp & 2 & control, $\theta$ & Controlled rotations or phase \\
        rxx, ryy, rzz & 2 & $\theta$ & Two-qubit interaction gates \\
        ccx & 3 & control$_1$, control$_2$ & Toffoli gate \\
        cswap & 3 & control, target$_1$, target$_2$ & Controlled-SWAP gate \\
        - & 0 & None & Control marker (non-target) \\
        w & 0 & None & No operation \\
        \bottomrule
    \end{tabular}
    \caption{Summary of the gate set used in the evolutionary framework.}
    \label{tab:gateset}
\end{table}

\subsubsection*{Example Chromosome} Figure~\ref{fig:chromosome_example} presents a representative chromosome for a 3-qubit system, showing the gate specification strings for each layer. Figure~\ref{fig:chromosome_matrix} shows a more intuitive visualisation of this with Figure each inner list in the 2D array running vertically. ~\ref{fig:chromosome_circuit} shows the interpreted quantum circuit resulting from this representation.

\begin{figure}[H]
    \centering
    [[‘h’, ‘w’, ‘w’], [‘cp(0,1,1.5707)’, ‘-’, ‘w’], [‘cp(0,2,0.7853)’, ‘w’, ‘-’], [‘w’, ‘h’, ‘w’],
    
    [‘w’, ‘cp(1,2,1.5707)’, ‘-’], [‘w’, ‘w’, ‘h’], [‘swap(0,2)’, ‘w’, ‘-’]].
    \caption{Chromosome Representation}
    \label{fig:chromosome_example}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tabular}{l | c c c c c c l}
        \toprule
        Qubit 0 & h & p(1,1.5707) & cp(2,0.7853) & w & w & w & swap(2) \\
        \midrule
        Qubit 1 & w & - & w & h & cp(2, 1.5707) & w & w\\
        \midrule
        Qubit 2 & w & w & - & w & - & h & - \\
        \bottomrule
    \end{tabular}
    \caption{Visual Chromosome Interpretation}
    \label{fig:chromosome_matrix}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{Images/qft_traditional.png}
    \caption{Interpreted quantum circuit derived from the chromosome}
    \label{fig:chromosome_circuit}
\end{figure}

\subsubsection*{Layer Construction}
The creation of a new layer is governed by a stochastic process implemented in the \texttt{create\_new\_layer()} function. Each qubit position is assigned a gate drawn from a weighted distribution, where the no-op gate (\texttt{"w"}) has a fixed probability, and the remainder is split among valid single-, double-, and triple-qubit gates. If a multi-qubit gate is selected, the appropriate control qubit(s) are assigned using free indices in the layer, and their positions are marked with \texttt{"-"}. This ensures no gate overlaps occur within a single timestep, preserving physical validity.

\subsubsection*{Parsing and Circuit Construction}
Once the chromosome is fully constructed, the gate specification strings are parsed using \texttt{parse\_gate\_spec()}, which extracts the gate name and arguments. A mapping table implemented in \texttt{build\_gate\_map()} links each gate to a corresponding Qiskit function. The final circuit is assembled via \texttt{get\_circuits()}, which processes the chromosome layer-by-layer and applies each gate to a growing \texttt{QuantumCircuit} object. All operations in a layer are executed in parallel.

\subsubsection*{Advantages}

This representation offers several benefits:
\begin{itemize}
    \item \textbf{Parallelism-aware:} Enables concurrent gate execution, reducing circuit depth and noise accumulation.
    \item \textbf{Genetically robust:} Supports meaningful crossover and mutation at the layer level without violating circuit integrity.
    \item \textbf{Hardware-aligned:} Compatible with transpiler constraints and hardware scheduling on real quantum devices.
    \item \textbf{Semantically expressive:} Encodes both gate type and qubit roles compactly, including support for parametrised operations.
\end{itemize}

In summary, this layer-based circuit representation enables both expressive modelling and efficient evolution of quantum circuits under noisy constraints. Its compatibility with hardware and genetic operators makes it a core component of the evolutionary framework presented in this work.


\subsection{Genetic Operators}
The evolutionary process in this work is driven by a suite of custom genetic operators tailored to the layered circuit representation. These operators explore the solution space, maintain diversity, and guide the search towards functionally correct, low‐depth, noise‐resilient quantum circuits. The standard three‐stage paradigm of selection, crossover and mutation is retained, but each stage has been adapted to the particular constraints and opportunities of NISQ‐era quantum circuit design.

\subsubsection*{Parent Selection}
Parent selection determines which individuals contribute genetic material to the next generation, directly affecting both convergence speed and population diversity. In our experiments we systematically compared several well‐known strategies:

\begin{itemize}
    \item Random selection picks individuals uniformly at random, guaranteeing maximal exploration but offering no preference for higher‐fitness solutions. Early trials showed that this approach led to erratic progress and slow convergence, as good solutions were no more likely to reproduce than poor ones.

    \item Fitness‐proportionate (roulette‐wheel) selection assigns reproduction probability proportional to an individual’s fitness. While this method rewards better solutions, it suffered from severe fitness scaling issues: when a few individuals achieved markedly higher fitness, they came to dominate reproduction, leading to premature convergence and loss of diversity.

    \item Tournament selection samples a small subset of the population and selects the best among them. Varying the tournament size allowed us to tune selection pressure, but the stochastic nature of sampling introduced high variance in convergence rates, especially for small populations. An elitist variant—guaranteeing the best of each tournament advanced unconditionally—improved stability but still exhibited occasional regressions.
\end{itemize}

After extensive testing, rank‐based selection with elitism emerged as the most effective. In this method, all individuals are sorted by fitness and assigned ranks from 1 (lowest) to $N$ (highest). Selection probabilities increase linearly with rank, which normalises the effect of fitness differences and prevents outliers from overwhelming the gene pool. Concurrently, the top one‐third of the population is preserved unchanged into the next generation (elitism). This hybrid strategy ensures that superior solutions are never lost to stochastic fluctuations, while still permitting lower‐fitness individuals to contribute, thereby sustaining exploratory dynamics. Over dozens of runs, this approach delivered the fastest and most reliable improvements in circuit fidelity.

\subsubsection*{Crossover}
Crossover recombines structural information from two parent chromosomes to form offspring. Given the temporal and parallel nature of layer‐based circuits, we implemented a single‐point, layer‐wise crossover. Two parents are selected via the rank‐based mechanism described above, and a crossover point is chosen uniformly at random between valid layer indices. The child inherits all layers up to this point from Parent A, and the remaining layers from Parent B, preserving gate order and inter‐layer dependencies.

\begin{figure}[H]
  \centering
  \begin{subtable}{0.45\textwidth}
    \small
    \begin{tabularx}{\textwidth}{c|*{4}{>{\centering\arraybackslash}X}}
      \toprule
      \multicolumn{5}{c}{\textbf{Parent A}} \\
      \midrule
      Qubit & L0 & L1 & L2 & L3\\
      \midrule
      Qubit 0 & h & cp(1,1.57) & cp(2,0.78) & w \\
      Qubit 1 & w & - & w & h \\
      Qubit 2 & w & w & - & w \\
      \bottomrule
    \end{tabularx}
  \end{subtable}
  \hfill
  \begin{subtable}{0.45\textwidth}
    \small
    \begin{tabularx}{\textwidth}{c|*{4}{>{\centering\arraybackslash}X}}
      \toprule
      \multicolumn{5}{c}{\textbf{Parent B}} \\
      \midrule
      Qubit & L0 & L1 & L2 & L3\\
      \midrule
      Qubit 0 & x & h & z & w \\
      Qubit 1 & x & w & cz(1.00) & w \\
      Qubit 2 & w & ry(3.30) & - & h \\
      \bottomrule
    \end{tabularx}
  \end{subtable}
  \caption{Side‐by‐side parent chromosomes using \texttt{tabularx}.}
  \label{fig:parents_tabularx}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{subtable}{0.45\textwidth}
    \small
    \caption{Child 1 (layers 0-2 from Parent A, layer 3 from Parent B)}
    \label{tab:child1}
    \begin{tabularx}{\textwidth}{c|*{4}{>{\centering\arraybackslash}X}}
      \toprule
      \multicolumn{5}{c}{\textbf{Child A}} \\
      \midrule
      Qubit & L0 & L1 & L2 & L3 \\
      \midrule
      Qubit 0 & h & cp(1,1.57) & cp(2,0.78) & w \\
      Qubit 1 & w & – & w & w \\
      Qubit 2 & w & w & – & h \\
      \bottomrule
    \end{tabularx}
  \end{subtable}
  \hfill
  \begin{subtable}{0.45\textwidth}
    \small
    \caption{Child 2 (layers 0-2 from Parent B, layer 3 from Parent A)}
    \label{tab:child2}
    \begin{tabularx}{\textwidth}{c|*{4}{>{\centering\arraybackslash}X}}
      \toprule
      \multicolumn{5}{c}{\textbf{Child B}} \\
      \midrule
      Qubit & L0 & L1 & L2 & L3 \\
      \midrule
      Qubit 0 & x & h & z & w \\
      Qubit 1 & x & w & cz(1.00) & h \\
      Qubit 2 & w & ry(3.30) & – & w \\
      \bottomrule
    \end{tabularx}
  \end{subtable}
  \caption{Offspring chromosomes produced by single‑point, layer‑wise crossover (crossover point between layers 2 and 3).}
  \label{fig:children_tabularx}
\end{figure}

This crossover operator preserves the temporal integrity of gate sequences while enabling the mixing of high‐performance subcircuits. In practice, the recombination of fidelity‐preserving prefixes with noise‐resistant suffixes often yields offspring that outperform both parents after subsequent mutation.

\subsubsection*{Mutation}
Mutation introduces essential variation into the population, enabling the evolutionary process to escape local optima and discover novel circuit topologies. In our framework, mutation is applied at three hierarchical levels, each targeting a different aspect of the chromosome:
\begin{enumerate}
  \item \textbf{Gate‑level mutation} alters the type of a single gate within a layer, potentially rewiring entanglement patterns.
  \item \textbf{Parameter‑level mutation} perturbs the continuous rotation angles of parametrised gates, refining phase relationships.
  \item \textbf{Layer‑level mutation} inserts or deletes entire layers, adjusting circuit depth and temporal structure.
\end{enumerate}

At the gate level, each gate specification string in a chromosome is considered for replacement with probability \(p_{\mathrm{gate}}\). If chosen, the gate is swapped for another randomly selected operation from the supported set. For multi‑qubit gates, new control qubit indices are selected, and the corresponding partner positions in the layer are marked with the control placeholder (“\texttt{-}”). This can introduce new entangling gates or remove existing ones, significantly altering circuit behaviour.\newline

In parameter‑level mutation, each parametrised gate—such as \(\mathrm{R_x}(\theta)\), \(\mathrm{R_y}(\theta)\), or controlled‑phase \(\mathrm{CP}(\theta)\)—is assigned a small probability \(p_{\mathrm{param}}\) of having its angle \(\theta\) perturbed. The new angle is drawn from a normal distribution \(\mathcal{N}(0,\sigma^2)\) with standard deviation \(\sigma=0.1\), centred on the existing value. This fine‑tuned adjustment allows the algorithm to optimise phase relationships without changing the circuit’s overall architecture.\newline

Finally, layer‑level mutation applies with probability \(p_{\mathrm{layer}}\), whereby an entire layer may be deleted or replaced, and with a separate probability, a new randomly generated layer may be inserted at a uniform random position. Layer deletion can reduce overall circuit depth and hence noise exposure, whereas layer insertion may enable more complex transformations when beneficial. These structural operations interact directly with the depth penalty in the fitness function (Section~\ref{sec:fitness}), guiding the search towards circuits that balance fidelity against temporal cost.\newline

To illustrate these three mutation levels, Figure~\ref{fig:mutation_levels} presents examples for a 3‑qubit circuit:

\begin{figure}[H]
  \centering
  % Gate‑level mutation example
  \begin{subtable}{0.45\textwidth}
    \small
    \caption{Gate‑level mutation}
    \label{tab:gate_mutation}
    \begin{tabularx}{\textwidth}{c|*{2}{>{\centering\arraybackslash}X}}
      \toprule
      \textbf{}        & Original    & Mutated \\
      \midrule
      Qubit 0  & rx(0.3) & cp(1, 1.57) \\
      Qubit 1  & h & - \\
      Qubit 2  & w & w \\
      \bottomrule
    \end{tabularx}
  \end{subtable}
  \hfill
  % Parameter‑level mutation example
  \begin{subtable}{0.45\textwidth}
    \small
    \caption{Parameter‑level mutation}
    \label{tab:param_mutation}
    \begin{tabularx}{\textwidth}{c|*{2}{>{\centering\arraybackslash}X}}
      \toprule
      \textbf{}        & Original    & Mutated \\
      \midrule
      Qubit 0  & ry(1.00) & ry(1.15) \\
      Qubit 1  & w & w \\
      Qubit 2  & h & h \\
      \bottomrule
    \end{tabularx}
  \end{subtable}

  \vspace{1em}
  % Layer‑level mutation example
  \begin{subtable}{1\textwidth}
    \small
    \caption{Layer‑level mutation (deletion and insertion)}
    \label{tab:layer_mutation}
    \begin{tabularx}{\textwidth}{c|*{4}{>{\centering\arraybackslash}X}}
      \toprule
      \textbf{}               & \textbf{L0} & \textbf{L1} & \textbf{L2} & \textbf{L3} \\
      \midrule
      \emph{Original (Depth=3)} & [h, w] & [cx, -] & [ry(1.00), w] & \textbf{} \\
      \emph{After Deletion (D=2)} & [h, w] & [ry(1.00), w] & \textbf{} & \textbf{} \\
      \emph{After Insertion (D=4)}& [h, w]   & [cx, -]   & [ry(1.00), w]   & [-, cz(0.75)] \\
      \bottomrule
    \end{tabularx}
    \vspace{-0.5em}
  \end{subtable}

  \caption{Examples of the three mutation levels: gate‑level replacement, parameter perturbation, and layer‑level deletion/insertion.}
  \label{fig:mutation_levels}
\end{figure}

The combination of these mutation mechanisms ensures that the evolutionary framework can both refine promising circuits through local adjustments and explore entirely new architectures via structural rewiring. Hyperparameter tuning via grid search identified suitable probabilities for each mutation level, striking a balance between rigorous local search and broad exploratory jumps.

\subsection{Fitness Evaluation}
\label{sec:fitness}

The fitness function lies at the core of any evolutionary algorithm, providing the selective pressure that drives the population toward higher-performing solutions. In the context of quantum circuit synthesis, the fitness function must capture multiple, often conflicting objectives: fidelity to the desired quantum behaviour, resilience to noise, and compactness or depth of the circuit. The fitness function employed in this work is designed to balance these goals in a scalarised form, enabling efficient optimisation within a multi-objective evolutionary framework.

\subsubsection*{Fidelity to Ideal Behaviour}

At the most fundamental level, a quantum circuit must correctly implement its intended transformation. In this case, the target behaviour is that of the Quantum Fourier Transform (QFT). To quantify correctness, the evolved circuit is evaluated on every computational basis input state, and its output is compared to that of the ideal QFT circuit. This comparison is performed using Qiskit's \texttt{state\_fidelity} function, which computes the fidelity between two quantum states — in this case, density matrices — using the Uhlmann fidelity formula:

\[
\mathcal{F}(\rho_1, \rho_2) = \left( \mathrm{Tr}\left[ \sqrt{ \sqrt{\rho_1} \rho_2 \sqrt{\rho_1} } \right] \right)^2
\]

For an $n$-qubit system, the fitness of a candidate circuit $C$ is computed as the average fidelity over all $2^n$ basis states:

\[
F_{\text{base}} = \frac{1}{2^n} \sum_{i=0}^{2^n - 1} \mathcal{F} \left( \rho_{\text{ideal}}^{(i)}, \rho_{\text{circuit}}^{(i)} \right)
\]

This approach ensures that the evaluation accounts for both amplitude and phase accuracy — a critical requirement for QFT circuits — and captures the circuit’s behaviour across the entire Hilbert space, not just for a single input.

\subsubsection*{Noise-Aware Evaluation}

While fidelity to the ideal QFT is an important metric, real quantum hardware is inherently noisy. Thus, circuits that perform well in ideal simulations may degrade significantly when executed on physical devices. To address this, a secondary fidelity score is computed using Qiskit's AerSimulator with a custom noise model designed to reflect realistic quantum hardware behaviour. The model includes depolarising noise on single-, two-, and three-qubit gates, as well as amplitude and phase damping channels that emulate decoherence effects.\newline

For each basis input, the circuit is simulated under this noise model, and the output density matrix is compared to the corresponding ideal QFT output. The final noisy fidelity score is given by:

\[
F_{\text{noisy}} = \frac{1}{2^n} \sum_{i=0}^{2^n - 1} \mathcal{F} \left( \rho_{\text{ideal}}^{(i)}, \rho_{\text{noisy}}^{(i)} \right)
\]

This evaluation captures how well a candidate circuit preserves the QFT transformation in the presence of realistic gate errors, environmental noise, and readout imperfections. It also indirectly penalises deep circuits, which are more susceptible to decoherence.

\subsubsection*{Depth Penalty}

To explicitly discourage long, error-prone circuits, a regularisation term is applied in the form of a depth penalty. This penalises solutions with excessive layer counts, biasing the search toward more efficient designs. The penalised fitness score is defined as:

\[
F_{\text{final}} = F_{\text{noisy}} - \lambda D
\]

Here, $D$ is the circuit depth (number of layers), and $\lambda$ is a tunable scalar controlling the strength of the penalty. A value of $\lambda = 0.005$ was found to yield balanced optimisation in experiments, encouraging noise-aware depth reduction without over-penalising viable circuit structures.

\subsubsection*{Fitness Evaluation Pipeline}

In each generation, the fitness evaluation proceeds as follows. First, for each chromosome, a Qiskit circuit is constructed using the decoding functions described in Section 3.1. This circuit is applied to each computational basis input, and the resulting output states are saved as density matrices. Ideal QFT outputs are precomputed and stored. The fidelity of each output is computed using \texttt{state\_fidelity}, averaged over all inputs, and adjusted for depth. This final scalar score is stored in a fitness cache to avoid redundant computation in future generations.\newline

For example, consider a 3-qubit circuit that achieves an average noisy fidelity of 0.91 and has a depth of 14. Its final score is:

\[
F_{\text{final}} = 0.91 - 0.005 \times 14 = 0.84
\]

This composite score reflects the circuit’s ability to perform the QFT transformation accurately under noise, while maintaining architectural efficiency. It is this scalar fitness value that guides selection and reproduction, forming the basis of the evolutionary process.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Experimental Setup
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experimental Setup}
\subsection{Experimental Goals}
Placeholder

\subsection{Experimental Method}
Placeholder

\subsection{Experimental Limitations}
Placeholder

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Results & Evaluation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results and Evaluation}
\subsection{QFT Circuit Evolution}
Placeholder

\subsection{Comparative Analysis Under Noise}
Placeholder

\subsection{Structural Comparison of Evolved Circuits}
Placeholder

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Discussion & Critical Analysis
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion \& Critical Analysis}
(Approximately 3 pages) Reflect on your project outcomes.

\begin{itemize}
  \item Summarise the key findings and how each experimental variant performed.
  \item Discuss the impact of incorporating noise simulation and circuit depth into the fitness evaluation.
  \item Reflect on the strengths and weaknesses of your approach, including challenges in EA convergence and simulation limitations.
  \item Consider the feedback received on your literature review and project plan, and discuss how your approach addresses or could further refine the objectives.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Conclusions & Future Work
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions \& Future Work}

(Approximately 2 pages) Conclude your report with a summary and future directions.

\begin{itemize}
  \item Recap the main contributions and findings of your project.
  \item State which experimental configuration yielded the best trade-off between fidelity and noise resilience.
  \item Propose avenues for future work, such as testing on real quantum hardware or applying the approach to other quantum algorithms.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  References
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{section}{References}
\printbibliography

\end{document}
